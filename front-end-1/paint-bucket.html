<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
    />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      canvas {
        border: 1px solid #333;
      }
    </style>
  </head>
  <body>
    <button>目前使用畫筆</button>
    <hr />

    <canvas id="palette" width="360" height="150"></canvas>
    <canvas id="color"></canvas>
    <canvas id="pen" width="500" height="500"></canvas>
    <input type="range" id="pen-px" min="1" max="100" />
    <hr />
    <button id="download-button">Download</button>
    <script>
      let isPaintBucket = false;
      const button = document.querySelector("button");
      button.addEventListener("click", () => {
        isPaintBucket = !isPaintBucket;
        if (isPaintBucket) {
          button.textContent = "目前使用油漆桶";
        } else {
          button.textContent = "目前使用畫筆";
        }
      });

      for (let i = 0; i < 360; i++) {
        const gradient = paletteCtx.createLinearGradient(
          i,
          0,
          i + 1,
          paletteCvs.height
        );

        gradient.addColorStop(0, "black");
        gradient.addColorStop(0.5, `hsl(${i}, 100%, 50%)`);
        gradient.addColorStop(1, "white");

        paletteCtx.fillStyle = gradient;
        paletteCtx.fillRect(i, 0, 1, paletteCvs.height);
      }

      const colorCvs = document.querySelector("#color");
      const colorCtx = colorCvs.getContext("2d", { willReadFrequently: true });

      let isSelecting = false;

      penCvs.addEventListener("mousedown", (e) => {
        penX = e.offsetX;
        penY = e.offsetY;

        // start
        if (isPaintBucket) {
          const colorImageData = colorCtx.getImageData(0, 0, 1, 1);
          const newColor = colorImageData.data;
          const baseImageData = penCtx.getImageData(penX, penY, 1, 1);
          const baseColor = baseImageData.data;

          const imageData = penCtx.getImageData(
            0,
            0,
            penCvs.width,
            penCvs.height
          );
          const pixels = imageData.data;
          const queue = [[penX, penY]];

          while (queue.length) {
            const [x, y] = queue.shift();
            const startIndex = (y * penCvs.width + x) * 4;

            if (baseColor.every((x, i) => pixels[startIndex + i] === x)) {
              for (let i = 0; i < 4; i++) {
                pixels[startIndex + i] = newColor[i];
              }
              queue.push([x + 1, y]);
              queue.push([x - 1, y]);
              queue.push([x, y - 1]);
              queue.push([x, y + 1]);
            }
          }

          penCtx.putImageData(imageData, 0, 0);

          return;
          // End
        }

        ispening = true;
        penCtx.beginPath();
      });

      penCvs.addEventListener("mousemove", (e) => {
        if (ispening) {
          const x = e.offsetX;
          const y = e.offsetY;
          penCtx.lineWidth = penPx.value;
          penCtx.moveTo(penX, penY);
          penCtx.lineTo(x, y);
          penCtx.stroke();
          penX = e.offsetX;
          penY = e.offsetY;
        }
      });

      window.addEventListener("mouseup", (e) => {
        ispening = false;
      });

      const downloadButton = document.querySelector("#download-button");
      downloadButton.addEventListener("click", () => {
        const url = penCvs.toDataURL();
        const a = document.createElement("a");
        a.href = url;
        a.download = "image.jpg";
        a.click();
      });

      // paletteCvs

      const paletteCvs = document.querySelector("#palette");
      const paletteCtx = paletteCvs.getContext("2d", {
        willReadFrequently: true,
      });

      paletteCvs.addEventListener("mousedown", (e) => {
        isSelecting = true;
        const x = e.offsetX;
        const y = e.offsetY;
        const imageData = paletteCtx.getImageData(x, y, 1, 1);
        const [r, g, b, a] = imageData.data;
        colorCtx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
        colorCtx.fillRect(0, 0, colorCvs.width, colorCvs.height);
        penCtx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
      });

      paletteCvs.addEventListener("mousemove", (e) => {
        if (isSelecting) {
          const x = e.offsetX;
          const y = e.offsetY;
          const imageData = paletteCtx.getImageData(x, y, 1, 1);
          const [r, g, b, a] = imageData.data;
          colorCtx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
          colorCtx.fillRect(0, 0, colorCvs.width, colorCvs.height);
          penCtx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
        }
      });

      paletteCvs.addEventListener("mouseup", () => {
        isSelecting = false;
      });

      const penCvs = document.querySelector("#pen");
      const penPx = document.querySelector("#pen-px");
      const penCtx = penCvs.getContext("2d", { willReadFrequently: true });
      penCtx.fillStyle = "#fff";
      penCtx.fillRect(0, 0, penCvs.width, penCvs.height);
      penCtx.lineCap = "round";
      penCtx.lineJoin = "round";

      let ispening = false;
      let penX = 0;
      let penY = 0;
    </script>
  </body>
</html>
