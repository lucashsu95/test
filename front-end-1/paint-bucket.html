<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
    />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>bucket</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      canvas {
        border: 1px solid #333;
      }

      .color {
        width: 50px;
        height: 50px;
        border: 1px solid #bbb;
      }
    </style>
  </head>
  <body>
    <button>目前使用畫筆</button>
    <hr />

    palette:
    <canvas id="palette" width="360" height="150"></canvas>
    color:
    <div class="color"></div>
    pen:
    <canvas id="pen" width="500" height="500"></canvas>
    <hr />
    <script>
      let isPaintBucket = false;
      var color = [0, 0, 0];

      const button = document.querySelector("button");
      button.addEventListener("click", () => {
        isPaintBucket = !isPaintBucket;
        button.textContent = isPaintBucket ? "目前使用油漆桶" : "目前使用畫筆";
      });

      let isSelecting = false;
      const penCvs = document.querySelector("#pen");
      const penCtx = penCvs.getContext("2d", { willReadFrequently: true });
      let ispening = false;
      let penX = 0;
      let penY = 0;

      penCvs.addEventListener("mousedown", (e) => {
        penX = e.offsetX;
        penY = e.offsetY;

        // start

        if (isPaintBucket) {
          const newColor = color;
          const baseImageData = penCtx.getImageData(penX, penY, 1, 1);
          const baseColor = baseImageData.data;

          const imageData = penCtx.getImageData(
            0,
            0,
            penCvs.width,
            penCvs.height
          );
          const pixels = imageData.data;
          const queue = [[penX, penY]];

          while (queue.length) {
            const [x, y] = queue.shift();
            const startIndex = (y * penCvs.width + x) * 4;

            if (baseColor.every((x, i) => pixels[startIndex + i] === x)) {
              for (let i = 0; i < 4; i++) {
                pixels[startIndex + i] = newColor[i];
              }
              queue.push([x + 1, y]);
              queue.push([x - 1, y]);
              queue.push([x, y - 1]);
              queue.push([x, y + 1]);
            }
          }

          penCtx.putImageData(imageData, 0, 0);

          return;
          // End
        }

        // Pen

        ispening = true;
        penCtx.beginPath();
      });

      // MouseMove

      penCvs.addEventListener("mousemove", (e) => {
        if (ispening) {
          const x = e.offsetX;
          const y = e.offsetY;
          penCtx.lineWidth = 30;
          penCtx.moveTo(penX, penY);
          penCtx.lineTo(x, y);
          penCtx.stroke();
          penX = e.offsetX;
          penY = e.offsetY;
        }
      });

      // MouseUp

      window.addEventListener("mouseup", (e) => {
        ispening = false;
      });

      // paletteCvs
      const paletteCvs = document.querySelector("#palette");
      const colorDiv = document.querySelector(".color");
      const paletteCtx = paletteCvs.getContext("2d", {
        willReadFrequently: true,
      });

      for (let i = 0; i < 360; i++) {
        const gradient = paletteCtx.createLinearGradient(
          i,
          0,
          i + 1,
          paletteCvs.height
        );

        gradient.addColorStop(0, "black");
        gradient.addColorStop(0.5, `hsl(${i}, 100%, 50%)`);
        gradient.addColorStop(1, "white");

        paletteCtx.fillStyle = gradient;
        paletteCtx.fillRect(i, 0, 1, paletteCvs.height);
      }

      paletteCvs.addEventListener("mousedown", (e) => {
        isSelecting = true;
        const x = e.offsetX;
        const y = e.offsetY;
        const imageData = paletteCtx.getImageData(x, y, 1, 1);
        const [r, g, b, a] = imageData.data;
        color = imageData.data;
        penCtx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
        colorDiv.style.background = `rgba(${r}, ${g}, ${b}, ${a})`;
      });

      paletteCvs.addEventListener("mousemove", (e) => {
        if (isSelecting) {
          const x = e.offsetX;
          const y = e.offsetY;
          const imageData = paletteCtx.getImageData(x, y, 1, 1);
          const [r, g, b, a] = imageData.data;
          color = imageData.data;
          penCtx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
          colorDiv.style.background = `rgba(${r}, ${g}, ${b}, ${a})`;
        }
      });

      paletteCvs.addEventListener("mouseup", () => {
        isSelecting = false;
      });

      penCtx.fillStyle = "#fff";
      penCtx.fillRect(0, 0, penCvs.width, penCvs.height);
      penCtx.lineCap = "round";
      penCtx.lineJoin = "round";
    </script>
  </body>
</html>
